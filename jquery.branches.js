// Generated by CoffeeScript 1.3.3
(function($) {
  var Leaf, Tree, canvasSupport, defaults,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  canvasSupport = function() {
    var elem;
    return (elem = $('<canvas>')[0]) && (elem.getContext != null);
  };

  defaults = {
    automatic: true,
    style: ['#000', '#000'],
    width: 1.5,
    truncate: 12
  };

  $.fn.branches = function(cfg) {
    var root;
    root = $.data(this, 'root');
    if (root) {
      return root.refresh();
    } else {
      root = new Leaf(this);
      root.init($.extend({}, defaults, cfg));
      return $.data(this, 'root', root);
    }
  };

  Leaf = (function() {

    function Leaf(item, parent) {
      this.parent = parent;
      this.state = 'preinit';
      this.$item = $(item);
      this.$anchor = $('> a', this.$item);
    }

    Leaf.prototype.clear = function() {
      var ctx;
      if (this.canvas) {
        ctx = this.canvas.getContext('2d');
        return ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
      }
    };

    Leaf.prototype.connectTo = function(other, clear) {
      var ctx, _ref;
      if (!this.canvas) {
        return;
      }
      if (clear) {
        this.clear();
      }
      ctx = this.canvas.getContext('2d');
      ctx.lineWidth = this.cfg.width;
      ctx.strokeStyle = this.cfg.style[+((_ref = other.state) === 'on' || _ref === 'focused')];
      ctx.beginPath();
      ctx.moveTo(this.$anchor.outerWidth(), this.$anchor.position().top + (this.$anchor.outerHeight() / 2));
      ctx.lineTo(this.canvas.width, other.$anchor.position().top + (other.$anchor.outerHeight() / 2));
      return ctx.stroke();
    };

    Leaf.prototype.init = function(cfg) {
      var $anchor, $item, prop, s, text, tmp, word, _i, _len, _ref,
        _this = this;
      this.cfg = cfg;
      if (this.state !== 'preinit') {
        return;
      }
      this.state = 'initialized';
      if (this.parent) {
        this.cfg = this.parent.cfg;
        this.siblings = this.parent.children;
        if (this.cfg.truncate) {
          text = '';
          s = '';
          _ref = this.$anchor.text().split(' ');
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            word = _ref[_i];
            if ((tmp = text + s + word).length > this.cfg.truncate) {
              text += 'â€¦';
              break;
            }
            text = tmp;
            s = ' ';
          }
          this.$anchor.text(text);
        }
        this.$item.hover((function() {
          if (_this.state === 'off') {
            _this.siblings.invoke('on', 'blur');
            return _this.focus();
          }
        }), (function() {
          if (_this.state === 'focused') {
            _this.off();
            return _this.siblings.invoke('blurred', 'on');
          }
        }));
        this.$anchor.click(function() {
          (_this.state === 'on' ? _this.children : _this.siblings).invoke('off');
          return _this.on();
        });
      } else if (this.cfg.automatic) {
        this.$item.addClass('branches');
        $anchor = $('> a', $item = $('li:not(li.on)', this.$item));
        prop = 'border-left-color';
        if ($anchor.css(prop) === 'none') {
          prop = 'background-color';
        }
        this.cfg.style = [];
        this.cfg.style.push($anchor.css(prop));
        $item.addClass('on');
        this.cfg.style.push($anchor.css(prop));
        $item.removeClass('on');
        this.cfg.width = $anchor.css('border-left-width') || defaults.width;
        this.cfg.width = parseFloat(this.cfg.width);
      }
      this.children = new Tree($('> ul', this.$item), this);
      if (this.children.length && canvasSupport() && this.parent) {
        this.canvas = $('<canvas>').appendTo(this.$item).attr({
          height: Math.max(this.siblings.$list.height(), this.children.$list.height()),
          width: this.siblings.$list.width()
        }).get(0);
      }
      return this.children.invoke('init');
    };

    Leaf.prototype.on = function() {
      if (this.state !== 'on') {
        this.state = 'on';
        this.$item.addClass('on');
        if (this.parent) {
          this.parent.connectTo(this, true);
        }
        this.children.$list.show();
        return this.children.invoke('blurred', 'on');
      }
    };

    Leaf.prototype.off = function() {
      var _ref;
      if (this.state !== 'off') {
        if (this.parent && ((_ref = this.state) === 'on' || _ref === 'focused')) {
          this.parent.clear();
        }
        this.state = 'off';
        this.$item.removeClass('on');
        this.clear();
        this.children.$list.hide();
        return this.children.invoke('off');
      }
    };

    Leaf.prototype.focus = function() {
      if (this.state !== 'focused') {
        this.state = 'focused';
        this.$item.addClass('on');
        if (this.parent) {
          return this.parent.connectTo(this);
        }
      }
    };

    Leaf.prototype.blur = function() {
      if (this.state !== 'blurred') {
        this.state = 'blurred';
        this.$item.removeClass('on');
        if (this.parent) {
          this.parent.connectTo(this, true);
        }
        return this.children.invoke('on', 'blur');
      }
    };

    Leaf.prototype.refresh = function() {
      this[!this.parent || this.$item.hasClass('on') ? 'on' : 'off']();
      return this.children.invoke('refresh');
    };

    return Leaf;

  })();

  Tree = (function() {

    function Tree(list, parent) {
      var i, item, _i, _len, _ref;
      this.parent = parent;
      this.$list = $(list);
      this.$items = $('> li', this.$list);
      _ref = this.$items;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        item = _ref[i];
        this[i] = new Leaf(item, this.parent);
      }
      this.length = this.$items.length;
    }

    Tree.prototype.invoke = function(state, fn) {
      var i, node, _i, _len, _ref, _ref1, _results;
      if (arguments.length === 1) {
        _ref = [null, state], state = _ref[0], fn = _ref[1];
      }
      if (state) {
        state = [].concat(state);
      }
      _results = [];
      for (i = _i = 0, _len = this.length; _i < _len; i = ++_i) {
        node = this[i];
        if (node && (!state || (_ref1 = node.state, __indexOf.call(state, _ref1) >= 0))) {
          _results.push(node[fn]());
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    return Tree;

  })();
})(jQuery);
